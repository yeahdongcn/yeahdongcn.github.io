{"version":3,"sources":["webpack:///./node_modules/jexl/lib/parser/handlers.js","webpack:///./node_modules/jexl/lib/Jexl.js","webpack:///./node_modules/jexl/lib/Expression.js","webpack:///./node_modules/jexl/lib/evaluator/Evaluator.js","webpack:///./node_modules/jexl/lib/evaluator/handlers.js","webpack:///./node_modules/jexl/lib/Lexer.js","webpack:///./node_modules/jexl/lib/parser/Parser.js","webpack:///./node_modules/jexl/lib/parser/states.js","webpack:///./node_modules/jexl/lib/PromiseSync.js","webpack:///./node_modules/jexl/lib/grammar.js"],"names":["exports","argVal","ast","this","_cursor","args","push","arrayStart","_placeAtCursor","type","value","arrayVal","binaryOp","token","precedence","_grammar","parent","_parent","operator","node","left","_setParent","dot","_nextIdentEncapsulate","right","_nextIdentRelative","_relative","filter","_placeBeforeCursor","expr","relative","_subParser","isRelative","subject","identifier","from","literal","objKey","_curObjKey","objStart","objVal","subExpression","ternaryEnd","alternate","ternaryMid","consequent","ternaryStart","_tree","test","transform","name","unaryOp","Expression","defaultGrammar","elements","Jexl","bind","Object","assign","_lexer","_transforms","fn","_addGrammarElement","eval","weight","Infinity","map","key","hasOwnProperty","expression","createExpression","compile","lang","_getLang","context","evalSync","strs","exprStr","reduce","acc","str","idx","length","obj","grammar","transforms","module","Evaluator","Lexer","Parser","PromiseSync","_lang","_exprStr","_ast","lexer","parser","tokens","tokenize","addTokens","complete","_eval","Promise","res","error","promise","resolve","then","_getAst","undefined","handlers","relativeContext","_context","_relContext","call","arr","all","elem","keys","result","asts","vals","forEach","val","promises","Array","isArray","evalInst","values","results","ArrayLiteral","evalArray","BinaryExpression","ConditionalExpression","FilterExpression","_filterRelative","_filterStatic","Identifier","Literal","ObjectLiteral","evalMap","Transform","Error","apply","concat","UnaryExpression","numericRegex","identRegex","escEscRegex","whitespaceRegex","preOpRegexElems","postOpRegexElems","minusNegatesAfter","regex","_getSplitRegex","split","negate","i","_isWhitespace","raw","_isNegative","_createToken","getElements","getTokens","element","_unquote","match","parseFloat","replace","_splitRegex","elemArray","sort","a","b","_escapeRegExp","RegExp","join","some","quote","escQuoteRegex","substr","states","prefix","stopMap","_state","_stopMap","state","startExpr","subHandler","_startSubExpression","stopState","addToken","_endSubExpression","_parentStop","tokenTypes","typeOpts","handleFunc","handler","toState","completable","defineProperty","writable","endStates","h","expectOperand","openParen","openCurl","openBracket","expectBinOp","pipe","question","expectTransform","expectObjKey","closeCurl","expectKeyValSep","colon","postTransform","postTransformArgs","traverse","closeBracket","closeParen","comma","_resolve","_reject","rejected","e","resolved","catch","reject","Math","floor","pow","in","indexOf"],"mappings":"6EASAA,EAAQC,OAAS,SAASC,GACxBC,KAAKC,QAAQC,KAAKC,KAAKJ,IAOzBF,EAAQO,WAAa,WACnBJ,KAAKK,eAAe,CAClBC,KAAM,eACNC,MAAO,MAQXV,EAAQW,SAAW,SAAST,GACtBA,GACFC,KAAKC,QAAQM,MAAMJ,KAAKJ,IAS5BF,EAAQY,SAAW,SAASC,GAC1B,MAAMC,EAAaX,KAAKY,SAASF,EAAMH,OAAOI,YAAc,EAC5D,IAAIE,EAASb,KAAKC,QAAQa,QAC1B,KACED,GACAA,EAAOE,UACPf,KAAKY,SAASC,EAAOE,UAAUJ,YAAcA,GAE7CX,KAAKC,QAAUY,EACfA,EAASA,EAAOC,QAElB,MAAME,EAAO,CACXV,KAAM,mBACNS,SAAUL,EAAMH,MAChBU,KAAMjB,KAAKC,SAEbD,KAAKkB,WAAWlB,KAAKC,QAASe,GAC9BhB,KAAKC,QAAUY,EACfb,KAAKK,eAAeW,IAQtBnB,EAAQsB,IAAM,WACZnB,KAAKoB,sBACHpB,KAAKC,SACiB,oBAAtBD,KAAKC,QAAQK,OACU,qBAAtBN,KAAKC,QAAQK,MACW,qBAAtBN,KAAKC,QAAQK,MAA+BN,KAAKC,QAAQoB,OAC9DrB,KAAKsB,oBACFtB,KAAKC,SAAYD,KAAKC,UAAYD,KAAKoB,sBACtCpB,KAAKsB,qBACPtB,KAAKuB,WAAY,IASrB1B,EAAQ2B,OAAS,SAASzB,GACxBC,KAAKyB,mBAAmB,CACtBnB,KAAM,mBACNoB,KAAM3B,EACN4B,SAAU3B,KAAK4B,WAAWC,aAC1BC,QAAS9B,KAAKC,WAQlBJ,EAAQkC,WAAa,SAASrB,GAC5B,MAAMM,EAAO,CACXV,KAAM,aACNC,MAAOG,EAAMH,OAEXP,KAAKoB,uBACPJ,EAAKgB,KAAOhC,KAAKC,QACjBD,KAAKyB,mBAAmBT,GACxBhB,KAAKoB,uBAAwB,IAEzBpB,KAAKsB,qBACPN,EAAKW,UAAW,EAChB3B,KAAKsB,oBAAqB,GAE5BtB,KAAKK,eAAeW,KASxBnB,EAAQoC,QAAU,SAASvB,GACzBV,KAAKK,eAAe,CAClBC,KAAM,UACNC,MAAOG,EAAMH,SAQjBV,EAAQqC,OAAS,SAASxB,GACxBV,KAAKmC,WAAazB,EAAMH,OAO1BV,EAAQuC,SAAW,WACjBpC,KAAKK,eAAe,CAClBC,KAAM,gBACNC,MAAO,MASXV,EAAQwC,OAAS,SAAStC,GACxBC,KAAKC,QAAQM,MAAMP,KAAKmC,YAAcpC,GAQxCF,EAAQyC,cAAgB,SAASvC,GAC/BC,KAAKK,eAAeN,IAOtBF,EAAQ0C,WAAa,SAASxC,GAC5BC,KAAKC,QAAQuC,UAAYzC,GAO3BF,EAAQ4C,WAAa,SAAS1C,GAC5BC,KAAKC,QAAQyC,WAAa3C,GAQ5BF,EAAQ8C,aAAe,WACrB3C,KAAK4C,MAAQ,CACXtC,KAAM,wBACNuC,KAAM7C,KAAK4C,OAEb5C,KAAKC,QAAUD,KAAK4C,OAQtB/C,EAAQiD,UAAY,SAASpC,GAC3BV,KAAKyB,mBAAmB,CACtBnB,KAAM,YACNyC,KAAMrC,EAAMH,MACZL,KAAM,GACN4B,QAAS9B,KAAKC,WASlBJ,EAAQmD,QAAU,SAAStC,GACzBV,KAAKK,eAAe,CAClBC,KAAM,kBACNS,SAAUL,EAAMH,U,qBCjNpB,MAAM0C,EAAa,EAAQ,MACrBC,EAAiB,EAAQ,MAAaC,SAQ5C,MAAMC,EACJ,cAEEpD,KAAK0B,KAAO1B,KAAK0B,KAAK2B,KAAKrD,MAC3BA,KAAKY,SAAW0C,OAAOC,OAAO,GAAIL,GAClClD,KAAKwD,OAAS,KACdxD,KAAKyD,YAAc,GAmBrB,YAAY1C,EAAUJ,EAAY+C,GAChC1D,KAAK2D,mBAAmB5C,EAAU,CAChCT,KAAM,WACNK,WAAYA,EACZiD,KAAMF,IAaV,WAAW3C,EAAU2C,GACnB1D,KAAK2D,mBAAmB5C,EAAU,CAChCT,KAAM,UACNuD,OAAQC,IACRF,KAAMF,IAaV,aAAaX,EAAMW,GACjB1D,KAAKyD,YAAYV,GAAQW,EAQ3B,cAAcK,KACZ,IAAK,IAAIC,KAAOD,IACVA,IAAIE,eAAeD,KACrBhE,KAAKyD,YAAYO,GAAOD,IAAIC,IAalC,QAAQE,GAEN,OADgBlE,KAAKmE,iBAAiBD,GACvBE,UASjB,iBAAiBF,GACf,MAAMG,EAAOrE,KAAKsE,WAClB,OAAO,IAAIrB,EAAWoB,EAAMH,GAQ9B,aAAanB,GACX,OAAO/C,KAAKyD,YAAYV,GAU1B,KAAKmB,EAAYK,EAAU,IAEzB,OADgBvE,KAAKmE,iBAAiBD,GACvBN,KAAKW,GAWtB,SAASL,EAAYK,EAAU,IAE7B,OADgBvE,KAAKmE,iBAAiBD,GACvBM,SAASD,GAG1B,KAAKE,KAASvE,GACZ,MAAMwE,EAAUD,EAAKE,OAAO,CAACC,EAAKC,EAAKC,IAErCF,GAAOC,GADKC,EAAM5E,EAAK6E,OAAS7E,EAAK4E,GAAO,IAG3C,IACH,OAAO9E,KAAKmE,iBAAiBO,GAO/B,SAAS3D,IAELf,KAAKY,SAASG,IACoB,aAAjCf,KAAKY,SAASG,GAAUT,MACU,YAAjCN,KAAKY,SAASG,GAAUT,aAEnBN,KAAKY,SAASG,GAWzB,mBAAmB8D,EAAKG,GACtBhF,KAAKY,SAASiE,GAAOG,EAUvB,WACE,MAAO,CACLC,QAASjF,KAAKY,SACdsE,WAAYlF,KAAKyD,cAKvB0B,EAAOtF,QAAU,IAAIuD,EACrB+B,EAAOtF,QAAQuD,KAAOA,G,qBCjMtB,MAAMgC,EAAY,EAAQ,MACpBC,EAAQ,EAAQ,MAChBC,EAAS,EAAQ,MACjBC,EAAc,EAAQ,MAoE5BJ,EAAOtF,QAlEP,MACE,YAAYwE,EAAMK,GAChB1E,KAAKwF,MAAQnB,EACbrE,KAAKwD,OAAS,IAAI6B,EAAMhB,EAAKY,SAC7BjF,KAAKyF,SAAWf,EAChB1E,KAAK0F,KAAO,KASd,UACE,MAAMC,EAAQ,IAAIN,EAAMrF,KAAKwF,MAAMP,SAC7BW,EAAS,IAAIN,EAAOtF,KAAKwF,MAAMP,SAC/BY,EAASF,EAAMG,SAAS9F,KAAKyF,UAGnC,OAFAG,EAAOG,UAAUF,GACjB7F,KAAK0F,KAAOE,EAAOI,WACZhG,KAST,KAAKuE,EAAU,IACb,OAAOvE,KAAKiG,MAAM1B,EAAS2B,SAU7B,SAAS3B,EAAU,IACjB,MAAM4B,EAAMnG,KAAKiG,MAAM1B,EAASgB,GAChC,GAAIY,EAAIC,MAAO,MAAMD,EAAIC,MACzB,OAAOD,EAAI5F,MAGb,MAAMgE,EAAS8B,GACb,OAAOA,EAAQC,UAAUC,KAAK,KAC5B,MAAMxG,EAAMC,KAAKwG,UAQjB,OAPkB,IAAIpB,EACpBpF,KAAKwF,MAAMP,QACXjF,KAAKwF,MAAMN,WACXX,OACAkC,EACAJ,GAEezC,KAAK7D,KAI1B,UAEE,OADKC,KAAK0F,MAAM1F,KAAKoE,UACdpE,KAAK0F,Q,qBCnEhB,MAAMgB,EAAW,EAAQ,MAiCzB,MAAMtB,EACJ,YACEH,EACAC,EACAX,EACAoC,EACAN,EAAUH,SAEVlG,KAAKY,SAAWqE,EAChBjF,KAAKyD,YAAcyB,GAAc,GACjClF,KAAK4G,SAAWrC,GAAW,GAC3BvE,KAAK6G,YAAcF,GAAmB3G,KAAK4G,SAC3C5G,KAAKkG,QAAUG,EAQjB,KAAKtG,GACH,OAAOC,KAAKkG,QAAQI,UAAUC,KAAK,IAC1BG,EAAS3G,EAAIO,MAAMwG,KAAK9G,KAAMD,IAWzC,UAAUgH,GACR,OAAO/G,KAAKkG,QAAQc,IAAID,EAAIhD,IAAIkD,GAAQjH,KAAK4D,KAAKqD,KAWpD,QAAQlD,KACN,MAAMmD,EAAO5D,OAAO4D,KAAKnD,KACnBoD,EAAS,GACTC,EAAOF,EAAKnD,IAAIC,GACbhE,KAAK4D,KAAKG,IAAIC,KAEvB,OAAOhE,KAAKkG,QAAQc,IAAII,GAAMb,KAAKc,IACjCA,EAAKC,QAAQ,CAACC,EAAKzC,KACjBqC,EAAOD,EAAKpC,IAAQyC,IAEfJ,IAuBX,gBAAgBrF,EAASJ,GACvB,MAAM8F,EAAW,GAcjB,OAbKC,MAAMC,QAAQ5F,KACjBA,OAAsB2E,IAAZ3E,EAAwB,GAAK,CAACA,IAE1CA,EAAQwF,QAAQL,IACd,MAAMU,EAAW,IAAIvC,EACnBpF,KAAKY,SACLZ,KAAKyD,YACLzD,KAAK4G,SACLK,EACAjH,KAAKkG,SAEPsB,EAASrH,KAAKwH,EAAS/D,KAAKlC,MAEvB1B,KAAKkG,QAAQc,IAAIQ,GAAUjB,KAAKqB,IACrC,MAAMC,EAAU,GAMhB,OALAD,EAAON,QAAQ,CAAC/G,EAAOuE,KACjBvE,GACFsH,EAAQ1H,KAAK2B,EAAQgD,MAGlB+C,IAmBX,cAAc/F,EAASJ,GACrB,OAAO1B,KAAK4D,KAAKlC,GAAM6E,KAAKJ,GACP,kBAARA,EACFA,EAAMrE,OAAU2E,EAElB3E,EAAQqE,KAKrBhB,EAAOtF,QAAUuF,G,mBC1JjBvF,EAAQiI,aAAe,SAAS/H,GAC9B,OAAOC,KAAK+H,UAAUhI,EAAIQ,QAY5BV,EAAQmI,iBAAmB,SAASjI,GAClC,OAAOC,KAAKkG,QAAQc,IAAI,CAAChH,KAAK4D,KAAK7D,EAAIkB,MAAOjB,KAAK4D,KAAK7D,EAAIsB,SAASkF,KACnEQ,GAAO/G,KAAKY,SAASb,EAAIgB,UAAU6C,KAAKmD,EAAI,GAAIA,EAAI,MAcxDlH,EAAQoI,sBAAwB,SAASlI,GACvC,OAAOC,KAAK4D,KAAK7D,EAAI8C,MAAM0D,KAAKJ,GAC1BA,EACEpG,EAAI2C,WACC1C,KAAK4D,KAAK7D,EAAI2C,YAEhByD,EAEFnG,KAAK4D,KAAK7D,EAAIyC,aAYzB3C,EAAQqI,iBAAmB,SAASnI,GAClC,OAAOC,KAAK4D,KAAK7D,EAAI+B,SAASyE,KAAKzE,GAC7B/B,EAAI4B,SACC3B,KAAKmI,gBAAgBrG,EAAS/B,EAAI2B,MAEpC1B,KAAKoI,cAActG,EAAS/B,EAAI2B,QAc3C7B,EAAQwI,WAAa,SAAStI,GAC5B,OAAKA,EAAIiC,KAGFhC,KAAK4D,KAAK7D,EAAIiC,MAAMuE,KAAKhC,IAC9B,GAAIA,QAMJ,OAHIkD,MAAMC,QAAQnD,KAChBA,EAAUA,EAAQ,IAEbA,EAAQxE,EAAIQ,SATZR,EAAI4B,SAAW3B,KAAK6G,YAAY9G,EAAIQ,OAASP,KAAK4G,SAAS7G,EAAIQ,QAoB1EV,EAAQyI,QAAU,SAASvI,GACzB,OAAOA,EAAIQ,OAWbV,EAAQ0I,cAAgB,SAASxI,GAC/B,OAAOC,KAAKwI,QAAQzI,EAAIQ,QAY1BV,EAAQ4I,UAAY,SAAS1I,GAC3B,MAAM+C,EAAY9C,KAAKyD,YAAY1D,EAAIgD,MACvC,IAAKD,EACH,MAAM,IAAI4F,MAAM,aAAa3I,EAAIgD,wBAEnC,OAAO/C,KAAKkG,QAAQc,IAAI,CACtBhH,KAAK4D,KAAK7D,EAAI+B,SACd9B,KAAK+H,UAAUhI,EAAIG,MAAQ,MAC1BqG,KAAKQ,GAAOjE,EAAU6F,MAAM,KAAM,CAAC5B,EAAI,IAAI6B,OAAO7B,EAAI,OAW3DlH,EAAQgJ,gBAAkB,SAAS9I,GACjC,OAAOC,KAAK4D,KAAK7D,EAAIsB,OAAOkF,KAAKlF,GAC/BrB,KAAKY,SAASb,EAAIgB,UAAU6C,KAAKvC,M,mBChJrC,MAAMyH,EAAe,oCACfC,EAAa,6BACbC,EAAc,OACdC,EAAkB,QAClBC,EAAkB,CAEtB,wBACA,wBAEA,OAEA,aACA,eAEIC,EAAmB,CAEvB,+BAEA,kCAEIC,EAAoB,CACxB,WACA,UACA,YACA,cACA,WACA,SAiOFjE,EAAOtF,QApNP,MACE,YAAYoF,GACVjF,KAAKY,SAAWqE,EASlB,YAAYJ,GACV,MAAMwE,EAAQrJ,KAAKsJ,iBACnB,OAAOzE,EAAI0E,MAAMF,GAAO7H,OAAOyF,GAEtBA,GAcX,UAAU9D,GACR,MAAM0C,EAAS,GACf,IAAI2D,GAAS,EACb,IAAK,IAAIC,EAAI,EAAGA,EAAItG,EAAS4B,OAAQ0E,IAC/BzJ,KAAK0J,cAAcvG,EAASsG,IAC1B5D,EAAOd,SACTc,EAAOA,EAAOd,OAAS,GAAG4E,KAAOxG,EAASsG,IAEnB,MAAhBtG,EAASsG,IAAczJ,KAAK4J,YAAY/D,GACjD2D,GAAS,GAELA,IACFrG,EAASsG,GAAK,IAAMtG,EAASsG,GAC7BD,GAAS,GAEX3D,EAAO1F,KAAKH,KAAK6J,aAAa1G,EAASsG,MAO3C,OAHID,GACF3D,EAAO1F,KAAKH,KAAK6J,aAAa,MAEzBhE,EA+BT,SAAShB,GACP,MAAM1B,EAAWnD,KAAK8J,YAAYjF,GAClC,OAAO7E,KAAK+J,UAAU5G,GAYxB,aAAa6G,SACX,MAAMtJ,EAAQ,CACZJ,KAAM,UACNC,MAAOyJ,QACPL,IAAKK,SAEP,GAAmB,MAAfA,QAAQ,IAA6B,MAAfA,QAAQ,GAChCtJ,EAAMH,MAAQP,KAAKiK,SAASD,cACvB,GAAIA,QAAQE,MAAMpB,GACvBpI,EAAMH,MAAQ4J,WAAWH,cACpB,GAAgB,SAAZA,SAAkC,UAAZA,QAC/BtJ,EAAMH,MAAoB,SAAZyJ,aACT,GAAIhK,KAAKY,SAASoJ,SACvBtJ,EAAMJ,KAAON,KAAKY,SAASoJ,SAAS1J,SAC/B,KAAI0J,QAAQE,MAAMnB,GAGvB,MAAM,IAAIL,MAAM,6BAA6BsB,SAF7CtJ,EAAMJ,KAAO,aAIf,OAAOI,EAWT,cAAcmE,GAKZ,OAJAA,EAAMA,EAAIuF,QAAQ,sBAAuB,SACjCF,MAAMnB,KACZlE,EAAM,MAAQA,EAAM,OAEfA,EAST,iBACE,IAAK7E,KAAKqK,YAAa,CAErB,MAAMC,EAAYhH,OAAO4D,KAAKlH,KAAKY,UAChC2J,KAAK,CAACC,EAAGC,IACDA,EAAE1F,OAASyF,EAAEzF,QAErBhB,IAAIkD,GACIjH,KAAK0K,cAAczD,GACzBjH,MACLA,KAAKqK,YAAc,IAAIM,OACrB,IACE,CACEzB,EAAgB0B,KAAK,KACrBN,EAAUM,KAAK,KACfzB,EAAiByB,KAAK,MACtBA,KAAK,KACP,KAGN,OAAO5K,KAAKqK,YAYd,YAAYxE,GACV,OAAKA,EAAOd,QACLqE,EAAkByB,KACvBvK,GAAQA,IAASuF,EAAOA,EAAOd,OAAS,GAAGzE,MAY/C,cAAcuE,GACZ,QAASA,EAAIqF,MAAMjB,GAcrB,SAASpE,GACP,MAAMiG,EAAQjG,EAAI,GACZkG,EAAgB,IAAIJ,OAAO,OAASG,EAAO,KACjD,OAAOjG,EACJmG,OAAO,EAAGnG,EAAIE,OAAS,GACvBqF,QAAQW,EAAeD,GACvBV,QAAQpB,EAAa,S,qBCvP5B,MAAMtC,EAAW,EAAQ,MACnBuE,EAAS,EAAQ,MAAYA,OAmBnC,MAAM3F,EACJ,YAAYL,EAASiG,EAAQC,GAC3BnL,KAAKY,SAAWqE,EAChBjF,KAAKoL,OAAS,gBACdpL,KAAK4C,MAAQ,KACb5C,KAAKyF,SAAWyF,GAAU,GAC1BlL,KAAKuB,WAAY,EACjBvB,KAAKqL,SAAWF,GAAW,GAa7B,SAASzK,GACP,GAAoB,aAAhBV,KAAKoL,OACP,MAAM,IAAI1C,MAAM,gDAElB,MAAM4C,EAAQL,EAAOjL,KAAKoL,QACpBG,EAAYvL,KAAKyF,SAEvB,GADAzF,KAAKyF,UAAY/E,EAAMiJ,IACnB2B,EAAME,WAAY,CACfxL,KAAK4B,YACR5B,KAAKyL,oBAAoBF,GAE3B,MAAMG,EAAY1L,KAAK4B,WAAW+J,SAASjL,GAC3C,GAAIgL,EAAW,CAEb,GADA1L,KAAK4L,oBACD5L,KAAK6L,YAAa,OAAOH,EAC7B1L,KAAKoL,OAASM,OAEX,KAAIJ,EAAMQ,WAAWpL,EAAMJ,MAY3B,IAAIN,KAAKqL,SAAS3K,EAAMJ,MAC7B,OAAON,KAAKqL,SAAS3K,EAAMJ,MAE3B,MAAM,IAAIoI,MACR,SAAShI,EAAMiJ,QAAQjJ,EAAMJ,mCAAmCN,KAAKyF,YAhBhC,CACvC,MAAMsG,EAAWT,EAAMQ,WAAWpL,EAAMJ,MACxC,IAAI0L,EAAatF,EAAShG,EAAMJ,MAC5ByL,EAASE,UACXD,EAAaD,EAASE,SAEpBD,GACFA,EAAWlF,KAAK9G,KAAMU,GAEpBqL,EAASG,UACXlM,KAAKoL,OAASW,EAASG,UAS3B,OAAO,EAST,UAAUrG,GACRA,EAAOyB,QAAQtH,KAAK2L,SAAU3L,MAWhC,WACE,GAAIA,KAAKC,UAAYgL,EAAOjL,KAAKoL,QAAQe,YACvC,MAAM,IAAIzD,MAAM,iCAAiC1I,KAAKyF,UAMxD,OAJIzF,KAAK4B,YACP5B,KAAK4L,oBAEP5L,KAAKoL,OAAS,WACPpL,KAAKC,QAAUD,KAAK4C,MAAQ,KAOrC,aACE,OAAO5C,KAAKuB,UAQd,oBACE0J,EAAOjL,KAAKoL,QAAQI,WAAW1E,KAAK9G,KAAMA,KAAK4B,WAAWoE,YAC1DhG,KAAK4B,WAAa,KAUpB,eAAeZ,GACRhB,KAAKC,SAGRD,KAAKC,QAAQoB,MAAQL,EACrBhB,KAAKkB,WAAWF,EAAMhB,KAAKC,UAH3BD,KAAK4C,MAAQ5B,EAKfhB,KAAKC,QAAUe,EAWjB,mBAAmBA,GACjBhB,KAAKC,QAAUD,KAAKC,QAAQa,QAC5Bd,KAAKK,eAAeW,GAYtB,WAAWA,EAAMH,GACfyC,OAAO8I,eAAepL,EAAM,UAAW,CACrCT,MAAOM,EACPwL,UAAU,IAUd,oBAAoB3H,GAClB,IAAI4H,EAAYrB,EAAOjL,KAAKoL,QAAQkB,UAC/BA,IACHtM,KAAK6L,aAAc,EACnBS,EAAYtM,KAAKqL,UAEnBrL,KAAK4B,WAAa,IAAI0D,EAAOtF,KAAKY,SAAU8D,EAAS4H,IAIzDnH,EAAOtF,QAAUyF,G,qBC5LjB,MAAMiH,EAAI,EAAQ,MAkClB1M,EAAQoL,OAAS,CACfuB,cAAe,CACbV,WAAY,CACV7J,QAAS,CAAEiK,QAAS,eACpBnK,WAAY,CAAEmK,QAAS,cACvBlJ,QAAS,GACTyJ,UAAW,CAAEP,QAAS,iBACtBQ,SAAU,CAAER,QAAS,eAAgBD,QAASM,EAAEnK,UAChDjB,IAAK,CAAE+K,QAAS,YAChBS,YAAa,CAAET,QAAS,WAAYD,QAASM,EAAEnM,cAGnDwM,YAAa,CACXd,WAAY,CACVrL,SAAU,CAAEyL,QAAS,iBACrBW,KAAM,CAAEX,QAAS,mBACjB/K,IAAK,CAAE+K,QAAS,YAChBY,SAAU,CAAEZ,QAAS,aAAcD,QAASM,EAAE5J,eAEhDwJ,aAAa,GAEfY,gBAAiB,CACfjB,WAAY,CACV/J,WAAY,CAAEmK,QAAS,gBAAiBD,QAASM,EAAEzJ,aAGvDkK,aAAc,CACZlB,WAAY,CACV/J,WAAY,CAAEmK,QAAS,kBAAmBD,QAASM,EAAErK,QACrD+K,UAAW,CAAEf,QAAS,iBAG1BgB,gBAAiB,CACfpB,WAAY,CACVqB,MAAO,CAAEjB,QAAS,YAGtBkB,cAAe,CACbtB,WAAY,CACVW,UAAW,CAAEP,QAAS,UACtBzL,SAAU,CAAEyL,QAAS,iBACrB/K,IAAK,CAAE+K,QAAS,YAChBS,YAAa,CAAET,QAAS,UACxBW,KAAM,CAAEX,QAAS,oBAEnBC,aAAa,GAEfkB,kBAAmB,CACjBvB,WAAY,CACVrL,SAAU,CAAEyL,QAAS,iBACrB/K,IAAK,CAAE+K,QAAS,YAChBS,YAAa,CAAET,QAAS,UACxBW,KAAM,CAAEX,QAAS,oBAEnBC,aAAa,GAEfpK,WAAY,CACV+J,WAAY,CACVrL,SAAU,CAAEyL,QAAS,iBACrB/K,IAAK,CAAE+K,QAAS,YAChBS,YAAa,CAAET,QAAS,UACxBW,KAAM,CAAEX,QAAS,mBACjBY,SAAU,CAAEZ,QAAS,aAAcD,QAASM,EAAE5J,eAEhDwJ,aAAa,GAEfmB,SAAU,CACRxB,WAAY,CACV/J,WAAY,CAAEmK,QAAS,gBAG3B1K,OAAQ,CACNgK,WAAYe,EAAE/K,OACd8K,UAAW,CACTiB,aAAc,eAGlBjL,cAAe,CACbkJ,WAAYe,EAAEjK,cACdgK,UAAW,CACTkB,WAAY,gBAGhB1N,OAAQ,CACN0L,WAAYe,EAAEzM,OACdwM,UAAW,CACTmB,MAAO,SACPD,WAAY,sBAGhBnL,OAAQ,CACNmJ,WAAYe,EAAElK,OACdiK,UAAW,CACTmB,MAAO,eACPR,UAAW,gBAGfzM,SAAU,CACRgL,WAAYe,EAAE/L,SACd8L,UAAW,CACTmB,MAAO,WACPF,aAAc,gBAGlB9K,WAAY,CACV+I,WAAYe,EAAE9J,WACd6J,UAAW,CACTa,MAAO,eAGX5K,WAAY,CACViJ,WAAYe,EAAEhK,WACd4J,aAAa,K,mBClJjB,MAAM5G,EACJ,YAAY7B,GACVA,EAAG1D,KAAK0N,SAASrK,KAAKrD,MAAOA,KAAK2N,QAAQtK,KAAKrD,OAGjD,MAAM4N,GACJ,GAAI5N,KAAKoG,MACP,IACEpG,KAAK0N,SAASE,EAAS5N,KAAKoG,QAC5B,MAAOyH,GACP7N,KAAK2N,QAAQE,GAGjB,OAAO7N,KAGT,KAAK8N,EAAUF,GACb,IAAK5N,KAAKoG,MACR,IACEpG,KAAK0N,SAASI,EAAS9N,KAAKO,QAC5B,MAAOsN,GACP7N,KAAK2N,QAAQE,GAIjB,OADID,GAAU5N,KAAK+N,MAAMH,GAClB5N,KAGT,QAAQoG,GACNpG,KAAKO,WAAQkG,EACbzG,KAAKoG,MAAQA,EAGf,SAASmB,GACHA,aAAehC,EACbgC,EAAInB,MACNpG,KAAK2N,QAAQpG,EAAInB,OAEjBpG,KAAK0N,SAASnG,EAAIhH,QAGpBP,KAAKO,MAAQgH,EACbvH,KAAKoG,WAAQK,IAKnBlB,EAAYyB,IAAMK,GAChB,IAAI9B,EAAYe,IAQdA,EAPiBe,EAAKtD,IAAIwD,IACxB,KAAOA,aAAehC,GAAa,CACjC,GAAIgC,EAAInB,MAAO,MAAMsC,MAAMnB,EAAInB,OAC/BmB,EAAMA,EAAIhH,MAEZ,OAAOgH,OAKbhC,EAAYe,QAAUiB,GAAO,IAAIhC,EAAYe,GAAWA,EAAQiB,IAEhEhC,EAAYyI,OAAS5H,GACnB,IAAIb,EAAY,CAACe,EAAS0H,IAAWA,EAAO5H,IAE9CjB,EAAOtF,QAAU0F,G,mBCzDjB1F,EAAQsD,SAAW,CACjB,IAAK,CAAE7C,KAAM,OACb,IAAK,CAAEA,KAAM,eACb,IAAK,CAAEA,KAAM,gBACb,IAAK,CAAEA,KAAM,QACb,IAAK,CAAEA,KAAM,YACb,IAAK,CAAEA,KAAM,aACb,IAAK,CAAEA,KAAM,SACb,IAAK,CAAEA,KAAM,SACb,IAAK,CAAEA,KAAM,aACb,IAAK,CAAEA,KAAM,cACb,IAAK,CAAEA,KAAM,YACb,IAAK,CACHA,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,EAAOI,GAEhC,IAAK,CACHf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,EAAOI,GAEhC,IAAK,CACHf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,EAAOI,GAEhC,IAAK,CACHf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,EAAOI,GAEhC,KAAM,CACJf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAU4M,KAAKC,MAAMjN,EAAOI,IAE3C,IAAK,CACHf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,EAAOI,GAEhC,IAAK,CACHf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAU4M,KAAKE,IAAIlN,EAAMI,IAExC,KAAM,CACJf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,GAAQI,GAEjC,KAAM,CACJf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,GAAQI,GAEjC,IAAK,CACHf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,EAAOI,GAEhC,KAAM,CACJf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,GAAQI,GAEjC,IAAK,CACHf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,EAAOI,GAEhC,KAAM,CACJf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,GAAQI,GAEjC,KAAM,CACJf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,GAAQI,GAEjC,KAAM,CACJf,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IAAUJ,GAAQI,GAEjC+M,GAAI,CACF9N,KAAM,WACNK,WAAY,GACZiD,KAAM,CAAC3C,EAAMI,IACU,iBAAVA,GACuB,IAAzBA,EAAMgN,QAAQpN,KAEnBwG,MAAMC,QAAQrG,IACTA,EAAMwJ,KAAK5D,GAAQA,IAAShG,IAKzC,IAAK,CACHX,KAAM,UACNK,WAAYmD,IACZF,KAAMvC,IAAUA","file":"vendors/pages/c/_cluster/apps/install.c3535f5d01c9ca672d4a.js","sourcesContent":["/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/**\n * Handles a subexpression that's used to define a transform argument's value.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.argVal = function(ast) {\n  this._cursor.args.push(ast)\n}\n\n/**\n * Handles new array literals by adding them as a new node in the AST,\n * initialized with an empty array.\n */\nexports.arrayStart = function() {\n  this._placeAtCursor({\n    type: 'ArrayLiteral',\n    value: []\n  })\n}\n\n/**\n * Handles a subexpression representing an element of an array literal.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.arrayVal = function(ast) {\n  if (ast) {\n    this._cursor.value.push(ast)\n  }\n}\n\n/**\n * Handles tokens of type 'binaryOp', indicating an operation that has two\n * inputs: a left side and a right side.\n * @param {{type: <string>}} token A token object\n */\nexports.binaryOp = function(token) {\n  const precedence = this._grammar[token.value].precedence || 0\n  let parent = this._cursor._parent\n  while (\n    parent &&\n    parent.operator &&\n    this._grammar[parent.operator].precedence >= precedence\n  ) {\n    this._cursor = parent\n    parent = parent._parent\n  }\n  const node = {\n    type: 'BinaryExpression',\n    operator: token.value,\n    left: this._cursor\n  }\n  this._setParent(this._cursor, node)\n  this._cursor = parent\n  this._placeAtCursor(node)\n}\n\n/**\n * Handles successive nodes in an identifier chain.  More specifically, it\n * sets values that determine how the following identifier gets placed in the\n * AST.\n */\nexports.dot = function() {\n  this._nextIdentEncapsulate =\n    this._cursor &&\n    this._cursor.type !== 'UnaryExpression' &&\n    (this._cursor.type !== 'BinaryExpression' ||\n      (this._cursor.type === 'BinaryExpression' && this._cursor.right))\n  this._nextIdentRelative =\n    !this._cursor || (this._cursor && !this._nextIdentEncapsulate)\n  if (this._nextIdentRelative) {\n    this._relative = true\n  }\n}\n\n/**\n * Handles a subexpression used for filtering an array returned by an\n * identifier chain.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.filter = function(ast) {\n  this._placeBeforeCursor({\n    type: 'FilterExpression',\n    expr: ast,\n    relative: this._subParser.isRelative(),\n    subject: this._cursor\n  })\n}\n\n/**\n * Handles identifier tokens by adding them as a new node in the AST.\n * @param {{type: <string>}} token A token object\n */\nexports.identifier = function(token) {\n  const node = {\n    type: 'Identifier',\n    value: token.value\n  }\n  if (this._nextIdentEncapsulate) {\n    node.from = this._cursor\n    this._placeBeforeCursor(node)\n    this._nextIdentEncapsulate = false\n  } else {\n    if (this._nextIdentRelative) {\n      node.relative = true\n      this._nextIdentRelative = false\n    }\n    this._placeAtCursor(node)\n  }\n}\n\n/**\n * Handles literal values, such as strings, booleans, and numerics, by adding\n * them as a new node in the AST.\n * @param {{type: <string>}} token A token object\n */\nexports.literal = function(token) {\n  this._placeAtCursor({\n    type: 'Literal',\n    value: token.value\n  })\n}\n\n/**\n * Queues a new object literal key to be written once a value is collected.\n * @param {{type: <string>}} token A token object\n */\nexports.objKey = function(token) {\n  this._curObjKey = token.value\n}\n\n/**\n * Handles new object literals by adding them as a new node in the AST,\n * initialized with an empty object.\n */\nexports.objStart = function() {\n  this._placeAtCursor({\n    type: 'ObjectLiteral',\n    value: {}\n  })\n}\n\n/**\n * Handles an object value by adding its AST to the queued key on the object\n * literal node currently at the cursor.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.objVal = function(ast) {\n  this._cursor.value[this._curObjKey] = ast\n}\n\n/**\n * Handles traditional subexpressions, delineated with the groupStart and\n * groupEnd elements.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.subExpression = function(ast) {\n  this._placeAtCursor(ast)\n}\n\n/**\n * Handles a completed alternate subexpression of a ternary operator.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.ternaryEnd = function(ast) {\n  this._cursor.alternate = ast\n}\n\n/**\n * Handles a completed consequent subexpression of a ternary operator.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.ternaryMid = function(ast) {\n  this._cursor.consequent = ast\n}\n\n/**\n * Handles the start of a new ternary expression by encapsulating the entire\n * AST in a ConditionalExpression node, and using the existing tree as the\n * test element.\n */\nexports.ternaryStart = function() {\n  this._tree = {\n    type: 'ConditionalExpression',\n    test: this._tree\n  }\n  this._cursor = this._tree\n}\n\n/**\n * Handles identifier tokens when used to indicate the name of a transform to\n * be applied.\n * @param {{type: <string>}} token A token object\n */\nexports.transform = function(token) {\n  this._placeBeforeCursor({\n    type: 'Transform',\n    name: token.value,\n    args: [],\n    subject: this._cursor\n  })\n}\n\n/**\n * Handles token of type 'unaryOp', indicating that the operation has only\n * one input: a right side.\n * @param {{type: <string>}} token A token object\n */\nexports.unaryOp = function(token) {\n  this._placeAtCursor({\n    type: 'UnaryExpression',\n    operator: token.value\n  })\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst Expression = require('./Expression')\nconst defaultGrammar = require('./grammar').elements\n\n/**\n * Jexl is the Javascript Expression Language, capable of parsing and\n * evaluating basic to complex expression strings, combined with advanced\n * xpath-like drilldown into native Javascript objects.\n * @constructor\n */\nclass Jexl {\n  constructor() {\n    // Allow expr to be called outside of the jexl context\n    this.expr = this.expr.bind(this)\n    this._grammar = Object.assign({}, defaultGrammar)\n    this._lexer = null\n    this._transforms = {}\n  }\n\n  /**\n   * Adds a binary operator to Jexl at the specified precedence. The higher the\n   * precedence, the earlier the operator is applied in the order of operations.\n   * For example, * has a higher precedence than +, because multiplication comes\n   * before division.\n   *\n   * Please see grammar.js for a listing of all default operators and their\n   * precedence values in order to choose the appropriate precedence for the\n   * new operator.\n   * @param {string} operator The operator string to be added\n   * @param {number} precedence The operator's precedence\n   * @param {function} fn A function to run to calculate the result. The function\n   *      will be called with two arguments: left and right, denoting the values\n   *      on either side of the operator. It should return either the resulting\n   *      value, or a Promise that resolves with the resulting value.\n   */\n  addBinaryOp(operator, precedence, fn) {\n    this._addGrammarElement(operator, {\n      type: 'binaryOp',\n      precedence: precedence,\n      eval: fn\n    })\n  }\n\n  /**\n   * Adds a unary operator to Jexl. Unary operators are currently only supported\n   * on the left side of the value on which it will operate.\n   * @param {string} operator The operator string to be added\n   * @param {function} fn A function to run to calculate the result. The function\n   *      will be called with one argument: the literal value to the right of the\n   *      operator. It should return either the resulting value, or a Promise\n   *      that resolves with the resulting value.\n   */\n  addUnaryOp(operator, fn) {\n    this._addGrammarElement(operator, {\n      type: 'unaryOp',\n      weight: Infinity,\n      eval: fn\n    })\n  }\n\n  /**\n   * Adds or replaces a transform function in this Jexl instance.\n   * @param {string} name The name of the transform function, as it will be used\n   *      within Jexl expressions\n   * @param {function} fn The function to be executed when this transform is\n   *      invoked. It will be provided with at least one argument:\n   *          - {*} value: The value to be transformed\n   *          - {...*} args: The arguments for this transform\n   */\n  addTransform(name, fn) {\n    this._transforms[name] = fn\n  }\n\n  /**\n   * Syntactic sugar for calling {@link #addTransform} repeatedly.  This function\n   * accepts a map of one or more transform names to their transform function.\n   * @param {{}} map A map of transform names to transform functions\n   */\n  addTransforms(map) {\n    for (let key in map) {\n      if (map.hasOwnProperty(key)) {\n        this._transforms[key] = map[key]\n      }\n    }\n  }\n\n  /**\n   * Creates an Expression object from the given Jexl expression string, and\n   * immediately compiles it. The returned Expression object can then be\n   * evaluated multiple times with new contexts, without generating any\n   * additional string processing overhead.\n   * @param {string} expression The Jexl expression to be compiled\n   * @returns {Expression} The compiled Expression object\n   */\n  compile(expression) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.compile()\n  }\n\n  /**\n   * Constructs an Expression object from a Jexl expression string.\n   * @param {string} expression The Jexl expression to be wrapped in an\n   *    Expression object\n   * @returns {Expression} The Expression object representing the given string\n   */\n  createExpression(expression) {\n    const lang = this._getLang()\n    return new Expression(lang, expression)\n  }\n\n  /**\n   * Retrieves a previously set transform function.\n   * @param {string} name The name of the transform function\n   * @returns {function} The transform function\n   */\n  getTransform(name) {\n    return this._transforms[name]\n  }\n\n  /**\n   * Asynchronously evaluates a Jexl string within an optional context.\n   * @param {string} expression The Jexl expression to be evaluated\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {Promise<*>} resolves with the result of the evaluation.\n   */\n  eval(expression, context = {}) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.eval(context)\n  }\n\n  /**\n   * Synchronously evaluates a Jexl string within an optional context.\n   * @param {string} expression The Jexl expression to be evaluated\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {*} the result of the evaluation.\n   * @throws {*} on error\n   */\n  evalSync(expression, context = {}) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.evalSync(context)\n  }\n\n  expr(strs, ...args) {\n    const exprStr = strs.reduce((acc, str, idx) => {\n      const arg = idx < args.length ? args[idx] : ''\n      acc += str + arg\n      return acc\n    }, '')\n    return this.createExpression(exprStr)\n  }\n\n  /**\n   * Removes a binary or unary operator from the Jexl grammar.\n   * @param {string} operator The operator string to be removed\n   */\n  removeOp(operator) {\n    if (\n      this._grammar[operator] &&\n      (this._grammar[operator].type === 'binaryOp' ||\n        this._grammar[operator].type === 'unaryOp')\n    ) {\n      delete this._grammar[operator]\n    }\n  }\n\n  /**\n   * Adds an element to the grammar map used by this Jexl instance.\n   * @param {string} str The key string to be added\n   * @param {{type: <string>}} obj A map of configuration options for this\n   *      grammar element\n   * @private\n   */\n  _addGrammarElement(str, obj) {\n    this._grammar[str] = obj\n  }\n\n  /**\n   * Gets an object defining the dynamic language elements of this Jexl\n   * instance.\n   * @returns {{ grammar: object, transforms: object }} A language definition\n   *    object\n   * @private\n   */\n  _getLang() {\n    return {\n      grammar: this._grammar,\n      transforms: this._transforms\n    }\n  }\n}\n\nmodule.exports = new Jexl()\nmodule.exports.Jexl = Jexl\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst Evaluator = require('./evaluator/Evaluator')\nconst Lexer = require('./Lexer')\nconst Parser = require('./parser/Parser')\nconst PromiseSync = require('./PromiseSync')\n\nclass Expression {\n  constructor(lang, exprStr) {\n    this._lang = lang\n    this._lexer = new Lexer(lang.grammar)\n    this._exprStr = exprStr\n    this._ast = null\n  }\n\n  /**\n   * Forces a compilation of the expression string that this Expression object\n   * was constructed with. This function can be called multiple times; useful\n   * if the language elements of the associated Jexl instance change.\n   * @returns {Expression} this Expression instance, for convenience\n   */\n  compile() {\n    const lexer = new Lexer(this._lang.grammar)\n    const parser = new Parser(this._lang.grammar)\n    const tokens = lexer.tokenize(this._exprStr)\n    parser.addTokens(tokens)\n    this._ast = parser.complete()\n    return this\n  }\n\n  /**\n   * Asynchronously evaluates the expression within an optional context.\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {Promise<*>} resolves with the result of the evaluation.\n   */\n  eval(context = {}) {\n    return this._eval(context, Promise)\n  }\n\n  /**\n   * Synchronously evaluates the expression within an optional context.\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {*} the result of the evaluation.\n   * @throws {*} on error\n   */\n  evalSync(context = {}) {\n    const res = this._eval(context, PromiseSync)\n    if (res.error) throw res.error\n    return res.value\n  }\n\n  _eval(context, promise) {\n    return promise.resolve().then(() => {\n      const ast = this._getAst()\n      const evaluator = new Evaluator(\n        this._lang.grammar,\n        this._lang.transforms,\n        context,\n        undefined,\n        promise\n      )\n      return evaluator.eval(ast)\n    })\n  }\n\n  _getAst() {\n    if (!this._ast) this.compile()\n    return this._ast\n  }\n}\n\nmodule.exports = Expression\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst handlers = require('./handlers')\n\n/**\n * The Evaluator takes a Jexl expression tree as generated by the\n * {@link Parser} and calculates its value within a given context. The\n * collection of transforms, context, and a relative context to be used as the\n * root for relative identifiers, are all specific to an Evaluator instance.\n * When any of these things change, a new instance is required.  However, a\n * single instance can be used to simultaneously evaluate many different\n * expressions, and does not have to be reinstantiated for each.\n * @param {{}} grammar A grammar map against which to evaluate the expression\n *      tree\n * @param {{}} [transforms] A map of transform names to transform functions. A\n *      transform function takes two arguments:\n *          - {*} val: A value to be transformed\n *          - {{}} args: A map of argument keys to their evaluated values, as\n *              specified in the expression string\n *      The transform function should return either the transformed value, or\n *      a Promises/A+ Promise object that resolves with the value and rejects\n *      or throws only when an unrecoverable error occurs. Transforms should\n *      generally return undefined when they don't make sense to be used on the\n *      given value type, rather than throw/reject. An error is only\n *      appropriate when the transform would normally return a value, but\n *      cannot due to some other failure.\n * @param {{}} [context] A map of variable keys to their values. This will be\n *      accessed to resolve the value of each non-relative identifier. Any\n *      Promise values will be passed to the expression as their resolved\n *      value.\n * @param {{}|Array<{}|Array>} [relativeContext] A map or array to be accessed\n *      to resolve the value of a relative identifier.\n * @param {function} promise A constructor for the Promise class to be used;\n *      probably either Promise or PromiseSync.\n */\nclass Evaluator {\n  constructor(\n    grammar,\n    transforms,\n    context,\n    relativeContext,\n    promise = Promise\n  ) {\n    this._grammar = grammar\n    this._transforms = transforms || {}\n    this._context = context || {}\n    this._relContext = relativeContext || this._context\n    this.Promise = promise\n  }\n\n  /**\n   * Evaluates an expression tree within the configured context.\n   * @param {{}} ast An expression tree object\n   * @returns {Promise<*>} resolves with the resulting value of the expression.\n   */\n  eval(ast) {\n    return this.Promise.resolve().then(() => {\n      return handlers[ast.type].call(this, ast)\n    })\n  }\n\n  /**\n   * Simultaneously evaluates each expression within an array, and delivers the\n   * response as an array with the resulting values at the same indexes as their\n   * originating expressions.\n   * @param {Array<string>} arr An array of expression strings to be evaluated\n   * @returns {Promise<Array<{}>>} resolves with the result array\n   */\n  evalArray(arr) {\n    return this.Promise.all(arr.map(elem => this.eval(elem)))\n  }\n\n  /**\n   * Simultaneously evaluates each expression within a map, and delivers the\n   * response as a map with the same keys, but with the evaluated result for each\n   * as their value.\n   * @param {{}} map A map of expression names to expression trees to be\n   *      evaluated\n   * @returns {Promise<{}>} resolves with the result map.\n   */\n  evalMap(map) {\n    const keys = Object.keys(map)\n    const result = {}\n    const asts = keys.map(key => {\n      return this.eval(map[key])\n    })\n    return this.Promise.all(asts).then(vals => {\n      vals.forEach((val, idx) => {\n        result[keys[idx]] = val\n      })\n      return result\n    })\n  }\n\n  /**\n   * Applies a filter expression with relative identifier elements to a subject.\n   * The intent is for the subject to be an array of subjects that will be\n   * individually used as the relative context against the provided expression\n   * tree. Only the elements whose expressions result in a truthy value will be\n   * included in the resulting array.\n   *\n   * If the subject is not an array of values, it will be converted to a single-\n   * element array before running the filter.\n   * @param {*} subject The value to be filtered usually an array. If this value is\n   *      not an array, it will be converted to an array with this value as the\n   *      only element.\n   * @param {{}} expr The expression tree to run against each subject. If the\n   *      tree evaluates to a truthy result, then the value will be included in\n   *      the returned array otherwise, it will be eliminated.\n   * @returns {Promise<Array>} resolves with an array of values that passed the\n   *      expression filter.\n   * @private\n   */\n  _filterRelative(subject, expr) {\n    const promises = []\n    if (!Array.isArray(subject)) {\n      subject = subject === undefined ? [] : [subject]\n    }\n    subject.forEach(elem => {\n      const evalInst = new Evaluator(\n        this._grammar,\n        this._transforms,\n        this._context,\n        elem,\n        this.Promise\n      )\n      promises.push(evalInst.eval(expr))\n    })\n    return this.Promise.all(promises).then(values => {\n      const results = []\n      values.forEach((value, idx) => {\n        if (value) {\n          results.push(subject[idx])\n        }\n      })\n      return results\n    })\n  }\n\n  /**\n   * Applies a static filter expression to a subject value.  If the filter\n   * expression evaluates to boolean true, the subject is returned if false,\n   * undefined.\n   *\n   * For any other resulting value of the expression, this function will attempt\n   * to respond with the property at that name or index of the subject.\n   * @param {*} subject The value to be filtered.  Usually an Array (for which\n   *      the expression would generally resolve to a numeric index) or an\n   *      Object (for which the expression would generally resolve to a string\n   *      indicating a property name)\n   * @param {{}} expr The expression tree to run against the subject\n   * @returns {Promise<*>} resolves with the value of the drill-down.\n   * @private\n   */\n  _filterStatic(subject, expr) {\n    return this.eval(expr).then(res => {\n      if (typeof res === 'boolean') {\n        return res ? subject : undefined\n      }\n      return subject[res]\n    })\n  }\n}\n\nmodule.exports = Evaluator\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/**\n * Evaluates an ArrayLiteral by returning its value, with each element\n * independently run through the evaluator.\n * @param {{type: 'ObjectLiteral', value: <{}>}} ast An expression tree with an\n *      ObjectLiteral as the top node\n * @returns {Promise.<[]>} resolves to a map contained evaluated values.\n * @private\n */\nexports.ArrayLiteral = function(ast) {\n  return this.evalArray(ast.value)\n}\n\n/**\n * Evaluates a BinaryExpression node by running the Grammar's evaluator for\n * the given operator.\n * @param {{type: 'BinaryExpression', operator: <string>, left: {},\n *      right: {}}} ast An expression tree with a BinaryExpression as the top\n *      node\n * @returns {Promise<*>} resolves with the value of the BinaryExpression.\n * @private\n */\nexports.BinaryExpression = function(ast) {\n  return this.Promise.all([this.eval(ast.left), this.eval(ast.right)]).then(\n    arr => this._grammar[ast.operator].eval(arr[0], arr[1])\n  )\n}\n\n/**\n * Evaluates a ConditionalExpression node by first evaluating its test branch,\n * and resolving with the consequent branch if the test is truthy, or the\n * alternate branch if it is not. If there is no consequent branch, the test\n * result will be used instead.\n * @param {{type: 'ConditionalExpression', test: {}, consequent: {},\n *      alternate: {}}} ast An expression tree with a ConditionalExpression as\n *      the top node\n * @private\n */\nexports.ConditionalExpression = function(ast) {\n  return this.eval(ast.test).then(res => {\n    if (res) {\n      if (ast.consequent) {\n        return this.eval(ast.consequent)\n      }\n      return res\n    }\n    return this.eval(ast.alternate)\n  })\n}\n\n/**\n * Evaluates a FilterExpression by applying it to the subject value.\n * @param {{type: 'FilterExpression', relative: <boolean>, expr: {},\n *      subject: {}}} ast An expression tree with a FilterExpression as the top\n *      node\n * @returns {Promise<*>} resolves with the value of the FilterExpression.\n * @private\n */\nexports.FilterExpression = function(ast) {\n  return this.eval(ast.subject).then(subject => {\n    if (ast.relative) {\n      return this._filterRelative(subject, ast.expr)\n    }\n    return this._filterStatic(subject, ast.expr)\n  })\n}\n\n/**\n * Evaluates an Identifier by either stemming from the evaluated 'from'\n * expression tree or accessing the context provided when this Evaluator was\n * constructed.\n * @param {{type: 'Identifier', value: <string>, [from]: {}}} ast An expression\n *      tree with an Identifier as the top node\n * @returns {Promise<*>|*} either the identifier's value, or a Promise that\n *      will resolve with the identifier's value.\n * @private\n */\nexports.Identifier = function(ast) {\n  if (!ast.from) {\n    return ast.relative ? this._relContext[ast.value] : this._context[ast.value]\n  }\n  return this.eval(ast.from).then(context => {\n    if (context === undefined || context === null) {\n      return undefined\n    }\n    if (Array.isArray(context)) {\n      context = context[0]\n    }\n    return context[ast.value]\n  })\n}\n\n/**\n * Evaluates a Literal by returning its value property.\n * @param {{type: 'Literal', value: <string|number|boolean>}} ast An expression\n *      tree with a Literal as its only node\n * @returns {string|number|boolean} The value of the Literal node\n * @private\n */\nexports.Literal = function(ast) {\n  return ast.value\n}\n\n/**\n * Evaluates an ObjectLiteral by returning its value, with each key\n * independently run through the evaluator.\n * @param {{type: 'ObjectLiteral', value: <{}>}} ast An expression tree with an\n *      ObjectLiteral as the top node\n * @returns {Promise<{}>} resolves to a map contained evaluated values.\n * @private\n */\nexports.ObjectLiteral = function(ast) {\n  return this.evalMap(ast.value)\n}\n\n/**\n * Evaluates a Transform node by applying a function from the transforms map\n * to the subject value.\n * @param {{type: 'Transform', name: <string>, subject: {}}} ast An\n *      expression tree with a Transform as the top node\n * @returns {Promise<*>|*} the value of the transformation, or a Promise that\n *      will resolve with the transformed value.\n * @private\n */\nexports.Transform = function(ast) {\n  const transform = this._transforms[ast.name]\n  if (!transform) {\n    throw new Error(`Transform ${ast.name} is not defined.`)\n  }\n  return this.Promise.all([\n    this.eval(ast.subject),\n    this.evalArray(ast.args || [])\n  ]).then(arr => transform.apply(null, [arr[0]].concat(arr[1])))\n}\n\n/**\n * Evaluates a Unary expression by passing the right side through the\n * operator's eval function.\n * @param {{type: 'UnaryExpression', operator: <string>, right: {}}} ast An\n *      expression tree with a UnaryExpression as the top node\n * @returns {Promise<*>} resolves with the value of the UnaryExpression.\n * @constructor\n */\nexports.UnaryExpression = function(ast) {\n  return this.eval(ast.right).then(right =>\n    this._grammar[ast.operator].eval(right)\n  )\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst numericRegex = /^-?(?:(?:[0-9]*\\.[0-9]+)|[0-9]+)$/\nconst identRegex = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/\nconst escEscRegex = /\\\\\\\\/\nconst whitespaceRegex = /^\\s*$/\nconst preOpRegexElems = [\n  // Strings\n  \"'(?:(?:\\\\\\\\')|[^'])*'\",\n  '\"(?:(?:\\\\\\\\\")|[^\"])*\"',\n  // Whitespace\n  '\\\\s+',\n  // Booleans\n  '\\\\btrue\\\\b',\n  '\\\\bfalse\\\\b'\n]\nconst postOpRegexElems = [\n  // Identifiers\n  '[a-zA-Z_\\\\$][a-zA-Z0-9_\\\\$]*',\n  // Numerics (without negative symbol)\n  '(?:(?:[0-9]*\\\\.[0-9]+)|[0-9]+)'\n]\nconst minusNegatesAfter = [\n  'binaryOp',\n  'unaryOp',\n  'openParen',\n  'openBracket',\n  'question',\n  'colon'\n]\n\n/**\n * Lexer is a collection of stateless, statically-accessed functions for the\n * lexical parsing of a Jexl string.  Its responsibility is to identify the\n * \"parts of speech\" of a Jexl expression, and tokenize and label each, but\n * to do only the most minimal syntax checking; the only errors the Lexer\n * should be concerned with are if it's unable to identify the utility of\n * any of its tokens.  Errors stemming from these tokens not being in a\n * sensible configuration should be left for the Parser to handle.\n * @type {{}}\n */\nclass Lexer {\n  constructor(grammar) {\n    this._grammar = grammar\n  }\n\n  /**\n   * Splits a Jexl expression string into an array of expression elements.\n   * @param {string} str A Jexl expression string\n   * @returns {Array<string>} An array of substrings defining the functional\n   *      elements of the expression.\n   */\n  getElements(str) {\n    const regex = this._getSplitRegex()\n    return str.split(regex).filter(elem => {\n      // Remove empty strings\n      return elem\n    })\n  }\n\n  /**\n   * Converts an array of expression elements into an array of tokens.  Note that\n   * the resulting array may not equal the element array in length, as any\n   * elements that consist only of whitespace get appended to the previous\n   * token's \"raw\" property.  For the structure of a token object, please see\n   * {@link Lexer#tokenize}.\n   * @param {Array<string>} elements An array of Jexl expression elements to be\n   *      converted to tokens\n   * @returns {Array<{type, value, raw}>} an array of token objects.\n   */\n  getTokens(elements) {\n    const tokens = []\n    let negate = false\n    for (let i = 0; i < elements.length; i++) {\n      if (this._isWhitespace(elements[i])) {\n        if (tokens.length) {\n          tokens[tokens.length - 1].raw += elements[i]\n        }\n      } else if (elements[i] === '-' && this._isNegative(tokens)) {\n        negate = true\n      } else {\n        if (negate) {\n          elements[i] = '-' + elements[i]\n          negate = false\n        }\n        tokens.push(this._createToken(elements[i]))\n      }\n    }\n    // Catch a - at the end of the string. Let the parser handle that issue.\n    if (negate) {\n      tokens.push(this._createToken('-'))\n    }\n    return tokens\n  }\n\n  /**\n   * Converts a Jexl string into an array of tokens.  Each token is an object\n   * in the following format:\n   *\n   *     {\n   *         type: <string>,\n   *         [name]: <string>,\n   *         value: <boolean|number|string>,\n   *         raw: <string>\n   *     }\n   *\n   * Type is one of the following:\n   *\n   *      literal, identifier, binaryOp, unaryOp\n   *\n   * OR, if the token is a control character its type is the name of the element\n   * defined in the Grammar.\n   *\n   * Name appears only if the token is a control string found in\n   * {@link grammar#elements}, and is set to the name of the element.\n   *\n   * Value is the value of the token in the correct type (boolean or numeric as\n   * appropriate). Raw is the string representation of this value taken directly\n   * from the expression string, including any trailing spaces.\n   * @param {string} str The Jexl string to be tokenized\n   * @returns {Array<{type, value, raw}>} an array of token objects.\n   * @throws {Error} if the provided string contains an invalid token.\n   */\n  tokenize(str) {\n    const elements = this.getElements(str)\n    return this.getTokens(elements)\n  }\n\n  /**\n   * Creates a new token object from an element of a Jexl string. See\n   * {@link Lexer#tokenize} for a description of the token object.\n   * @param {string} element The element from which a token should be made\n   * @returns {{value: number|boolean|string, [name]: string, type: string,\n   *      raw: string}} a token object describing the provided element.\n   * @throws {Error} if the provided string is not a valid expression element.\n   * @private\n   */\n  _createToken(element) {\n    const token = {\n      type: 'literal',\n      value: element,\n      raw: element\n    }\n    if (element[0] === '\"' || element[0] === \"'\") {\n      token.value = this._unquote(element)\n    } else if (element.match(numericRegex)) {\n      token.value = parseFloat(element)\n    } else if (element === 'true' || element === 'false') {\n      token.value = element === 'true'\n    } else if (this._grammar[element]) {\n      token.type = this._grammar[element].type\n    } else if (element.match(identRegex)) {\n      token.type = 'identifier'\n    } else {\n      throw new Error(`Invalid expression token: ${element}`)\n    }\n    return token\n  }\n\n  /**\n   * Escapes a string so that it can be treated as a string literal within a\n   * regular expression.\n   * @param {string} str The string to be escaped\n   * @returns {string} the RegExp-escaped string.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions\n   * @private\n   */\n  _escapeRegExp(str) {\n    str = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    if (str.match(identRegex)) {\n      str = '\\\\b' + str + '\\\\b'\n    }\n    return str\n  }\n\n  /**\n   * Gets a RegEx object appropriate for splitting a Jexl string into its core\n   * elements.\n   * @returns {RegExp} An element-splitting RegExp object\n   * @private\n   */\n  _getSplitRegex() {\n    if (!this._splitRegex) {\n      // Sort by most characters to least, then regex escape each\n      const elemArray = Object.keys(this._grammar)\n        .sort((a, b) => {\n          return b.length - a.length\n        })\n        .map(elem => {\n          return this._escapeRegExp(elem)\n        }, this)\n      this._splitRegex = new RegExp(\n        '(' +\n          [\n            preOpRegexElems.join('|'),\n            elemArray.join('|'),\n            postOpRegexElems.join('|')\n          ].join('|') +\n          ')'\n      )\n    }\n    return this._splitRegex\n  }\n\n  /**\n   * Determines whether the addition of a '-' token should be interpreted as a\n   * negative symbol for an upcoming number, given an array of tokens already\n   * processed.\n   * @param {Array<Object>} tokens An array of tokens already processed\n   * @returns {boolean} true if adding a '-' should be considered a negative\n   *      symbol; false otherwise\n   * @private\n   */\n  _isNegative(tokens) {\n    if (!tokens.length) return true\n    return minusNegatesAfter.some(\n      type => type === tokens[tokens.length - 1].type\n    )\n  }\n\n  /**\n   * A utility function to determine if a string consists of only space\n   * characters.\n   * @param {string} str A string to be tested\n   * @returns {boolean} true if the string is empty or consists of only spaces;\n   *      false otherwise.\n   * @private\n   */\n  _isWhitespace(str) {\n    return !!str.match(whitespaceRegex)\n  }\n\n  /**\n   * Removes the beginning and trailing quotes from a string, unescapes any\n   * escaped quotes on its interior, and unescapes any escaped escape\n   * characters. Note that this function is not defensive; it assumes that the\n   * provided string is not empty, and that its first and last characters are\n   * actually quotes.\n   * @param {string} str A string whose first and last characters are quotes\n   * @returns {string} a string with the surrounding quotes stripped and escapes\n   *      properly processed.\n   * @private\n   */\n  _unquote(str) {\n    const quote = str[0]\n    const escQuoteRegex = new RegExp('\\\\\\\\' + quote, 'g')\n    return str\n      .substr(1, str.length - 2)\n      .replace(escQuoteRegex, quote)\n      .replace(escEscRegex, '\\\\')\n  }\n}\n\nmodule.exports = Lexer\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst handlers = require('./handlers')\nconst states = require('./states').states\n\n/**\n * The Parser is a state machine that converts tokens from the {@link Lexer}\n * into an Abstract Syntax Tree (AST), capable of being evaluated in any\n * context by the {@link Evaluator}.  The Parser expects that all tokens\n * provided to it are legal and typed properly according to the grammar, but\n * accepts that the tokens may still be in an invalid order or in some other\n * unparsable configuration that requires it to throw an Error.\n * @param {{}} grammar The grammar map to use to parse Jexl strings\n * @param {string} [prefix] A string prefix to prepend to the expression string\n *      for error messaging purposes.  This is useful for when a new Parser is\n *      instantiated to parse an subexpression, as the parent Parser's\n *      expression string thus far can be passed for a more user-friendly\n *      error message.\n * @param {{}} [stopMap] A mapping of token types to any truthy value. When the\n *      token type is encountered, the parser will return the mapped value\n *      instead of boolean false.\n */\nclass Parser {\n  constructor(grammar, prefix, stopMap) {\n    this._grammar = grammar\n    this._state = 'expectOperand'\n    this._tree = null\n    this._exprStr = prefix || ''\n    this._relative = false\n    this._stopMap = stopMap || {}\n  }\n\n  /**\n   * Processes a new token into the AST and manages the transitions of the state\n   * machine.\n   * @param {{type: <string>}} token A token object, as provided by the\n   *      {@link Lexer#tokenize} function.\n   * @throws {Error} if a token is added when the Parser has been marked as\n   *      complete by {@link #complete}, or if an unexpected token type is added.\n   * @returns {boolean|*} the stopState value if this parser encountered a token\n   *      in the stopState mapb false if tokens can continue.\n   */\n  addToken(token) {\n    if (this._state === 'complete') {\n      throw new Error('Cannot add a new token to a completed Parser')\n    }\n    const state = states[this._state]\n    const startExpr = this._exprStr\n    this._exprStr += token.raw\n    if (state.subHandler) {\n      if (!this._subParser) {\n        this._startSubExpression(startExpr)\n      }\n      const stopState = this._subParser.addToken(token)\n      if (stopState) {\n        this._endSubExpression()\n        if (this._parentStop) return stopState\n        this._state = stopState\n      }\n    } else if (state.tokenTypes[token.type]) {\n      const typeOpts = state.tokenTypes[token.type]\n      let handleFunc = handlers[token.type]\n      if (typeOpts.handler) {\n        handleFunc = typeOpts.handler\n      }\n      if (handleFunc) {\n        handleFunc.call(this, token)\n      }\n      if (typeOpts.toState) {\n        this._state = typeOpts.toState\n      }\n    } else if (this._stopMap[token.type]) {\n      return this._stopMap[token.type]\n    } else {\n      throw new Error(\n        `Token ${token.raw} (${token.type}) unexpected in expression: ${this._exprStr}`\n      )\n    }\n    return false\n  }\n\n  /**\n   * Processes an array of tokens iteratively through the {@link #addToken}\n   * function.\n   * @param {Array<{type: <string>}>} tokens An array of tokens, as provided by\n   *      the {@link Lexer#tokenize} function.\n   */\n  addTokens(tokens) {\n    tokens.forEach(this.addToken, this)\n  }\n\n  /**\n   * Marks this Parser instance as completed and retrieves the full AST.\n   * @returns {{}|null} a full expression tree, ready for evaluation by the\n   *      {@link Evaluator#eval} function, or null if no tokens were passed to\n   *      the parser before complete was called\n   * @throws {Error} if the parser is not in a state where it's legal to end\n   *      the expression, indicating that the expression is incomplete\n   */\n  complete() {\n    if (this._cursor && !states[this._state].completable) {\n      throw new Error(`Unexpected end of expression: ${this._exprStr}`)\n    }\n    if (this._subParser) {\n      this._endSubExpression()\n    }\n    this._state = 'complete'\n    return this._cursor ? this._tree : null\n  }\n\n  /**\n   * Indicates whether the expression tree contains a relative path identifier.\n   * @returns {boolean} true if a relative identifier exists false otherwise.\n   */\n  isRelative() {\n    return this._relative\n  }\n\n  /**\n   * Ends a subexpression by completing the subParser and passing its result\n   * to the subHandler configured in the current state.\n   * @private\n   */\n  _endSubExpression() {\n    states[this._state].subHandler.call(this, this._subParser.complete())\n    this._subParser = null\n  }\n\n  /**\n   * Places a new tree node at the current position of the cursor (to the 'right'\n   * property) and then advances the cursor to the new node. This function also\n   * handles setting the parent of the new node.\n   * @param {{type: <string>}} node A node to be added to the AST\n   * @private\n   */\n  _placeAtCursor(node) {\n    if (!this._cursor) {\n      this._tree = node\n    } else {\n      this._cursor.right = node\n      this._setParent(node, this._cursor)\n    }\n    this._cursor = node\n  }\n\n  /**\n   * Places a tree node before the current position of the cursor, replacing\n   * the node that the cursor currently points to. This should only be called in\n   * cases where the cursor is known to exist, and the provided node already\n   * contains a pointer to what's at the cursor currently.\n   * @param {{type: <string>}} node A node to be added to the AST\n   * @private\n   */\n  _placeBeforeCursor(node) {\n    this._cursor = this._cursor._parent\n    this._placeAtCursor(node)\n  }\n\n  /**\n   * Sets the parent of a node by creating a non-enumerable _parent property\n   * that points to the supplied parent argument.\n   * @param {{type: <string>}} node A node of the AST on which to set a new\n   *      parent\n   * @param {{type: <string>}} parent An existing node of the AST to serve as the\n   *      parent of the new node\n   * @private\n   */\n  _setParent(node, parent) {\n    Object.defineProperty(node, '_parent', {\n      value: parent,\n      writable: true\n    })\n  }\n\n  /**\n   * Prepares the Parser to accept a subexpression by (re)instantiating the\n   * subParser.\n   * @param {string} [exprStr] The expression string to prefix to the new Parser\n   * @private\n   */\n  _startSubExpression(exprStr) {\n    let endStates = states[this._state].endStates\n    if (!endStates) {\n      this._parentStop = true\n      endStates = this._stopMap\n    }\n    this._subParser = new Parser(this._grammar, exprStr, endStates)\n  }\n}\n\nmodule.exports = Parser\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst h = require('./handlers')\n\n/**\n * A mapping of all states in the finite state machine to a set of instructions\n * for handling or transitioning into other states. Each state can be handled\n * in one of two schemes: a tokenType map, or a subHandler.\n *\n * Standard expression elements are handled through the tokenType object. This\n * is an object map of all legal token types to encounter in this state (and\n * any unexpected token types will generate a thrown error) to an options\n * object that defines how they're handled.  The available options are:\n *\n *      {string} toState: The name of the state to which to transition\n *          immediately after handling this token\n *      {string} handler: The handler function to call when this token type is\n *          encountered in this state.  If omitted, the default handler\n *          matching the token's \"type\" property will be called. If the handler\n *          function does not exist, no call will be made and no error will be\n *          generated.  This is useful for tokens whose sole purpose is to\n *          transition to other states.\n *\n * States that consume a subexpression should define a subHandler, the\n * function to be called with an expression tree argument when the\n * subexpression is complete. Completeness is determined through the\n * endStates object, which maps tokens on which an expression should end to the\n * state to which to transition once the subHandler function has been called.\n *\n * Additionally, any state in which it is legal to mark the AST as completed\n * should have a 'completable' property set to boolean true.  Attempting to\n * call {@link Parser#complete} in any state without this property will result\n * in a thrown Error.\n *\n * @type {{}}\n */\nexports.states = {\n  expectOperand: {\n    tokenTypes: {\n      literal: { toState: 'expectBinOp' },\n      identifier: { toState: 'identifier' },\n      unaryOp: {},\n      openParen: { toState: 'subExpression' },\n      openCurl: { toState: 'expectObjKey', handler: h.objStart },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'arrayVal', handler: h.arrayStart }\n    }\n  },\n  expectBinOp: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      pipe: { toState: 'expectTransform' },\n      dot: { toState: 'traverse' },\n      question: { toState: 'ternaryMid', handler: h.ternaryStart }\n    },\n    completable: true\n  },\n  expectTransform: {\n    tokenTypes: {\n      identifier: { toState: 'postTransform', handler: h.transform }\n    }\n  },\n  expectObjKey: {\n    tokenTypes: {\n      identifier: { toState: 'expectKeyValSep', handler: h.objKey },\n      closeCurl: { toState: 'expectBinOp' }\n    }\n  },\n  expectKeyValSep: {\n    tokenTypes: {\n      colon: { toState: 'objVal' }\n    }\n  },\n  postTransform: {\n    tokenTypes: {\n      openParen: { toState: 'argVal' },\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' }\n    },\n    completable: true\n  },\n  postTransformArgs: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' }\n    },\n    completable: true\n  },\n  identifier: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' },\n      question: { toState: 'ternaryMid', handler: h.ternaryStart }\n    },\n    completable: true\n  },\n  traverse: {\n    tokenTypes: {\n      identifier: { toState: 'identifier' }\n    }\n  },\n  filter: {\n    subHandler: h.filter,\n    endStates: {\n      closeBracket: 'identifier'\n    }\n  },\n  subExpression: {\n    subHandler: h.subExpression,\n    endStates: {\n      closeParen: 'expectBinOp'\n    }\n  },\n  argVal: {\n    subHandler: h.argVal,\n    endStates: {\n      comma: 'argVal',\n      closeParen: 'postTransformArgs'\n    }\n  },\n  objVal: {\n    subHandler: h.objVal,\n    endStates: {\n      comma: 'expectObjKey',\n      closeCurl: 'expectBinOp'\n    }\n  },\n  arrayVal: {\n    subHandler: h.arrayVal,\n    endStates: {\n      comma: 'arrayVal',\n      closeBracket: 'expectBinOp'\n    }\n  },\n  ternaryMid: {\n    subHandler: h.ternaryMid,\n    endStates: {\n      colon: 'ternaryEnd'\n    }\n  },\n  ternaryEnd: {\n    subHandler: h.ternaryEnd,\n    completable: true\n  }\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nclass PromiseSync {\n  constructor(fn) {\n    fn(this._resolve.bind(this), this._reject.bind(this))\n  }\n\n  catch(rejected) {\n    if (this.error) {\n      try {\n        this._resolve(rejected(this.error))\n      } catch (e) {\n        this._reject(e)\n      }\n    }\n    return this\n  }\n\n  then(resolved, rejected) {\n    if (!this.error) {\n      try {\n        this._resolve(resolved(this.value))\n      } catch (e) {\n        this._reject(e)\n      }\n    }\n    if (rejected) this.catch(rejected)\n    return this\n  }\n\n  _reject(error) {\n    this.value = undefined\n    this.error = error\n  }\n\n  _resolve(val) {\n    if (val instanceof PromiseSync) {\n      if (val.error) {\n        this._reject(val.error)\n      } else {\n        this._resolve(val.value)\n      }\n    } else {\n      this.value = val\n      this.error = undefined\n    }\n  }\n}\n\nPromiseSync.all = vals =>\n  new PromiseSync(resolve => {\n    const resolved = vals.map(val => {\n      while (val instanceof PromiseSync) {\n        if (val.error) throw Error(val.error)\n        val = val.value\n      }\n      return val\n    })\n    resolve(resolved)\n  })\n\nPromiseSync.resolve = val => new PromiseSync(resolve => resolve(val))\n\nPromiseSync.reject = error =>\n  new PromiseSync((resolve, reject) => reject(error))\n\nmodule.exports = PromiseSync\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/* eslint eqeqeq:0 */\n\n/**\n * A map of all expression elements to their properties. Note that changes\n * here may require changes in the Lexer or Parser.\n * @type {{}}\n */\nexports.elements = {\n  '.': { type: 'dot' },\n  '[': { type: 'openBracket' },\n  ']': { type: 'closeBracket' },\n  '|': { type: 'pipe' },\n  '{': { type: 'openCurl' },\n  '}': { type: 'closeCurl' },\n  ':': { type: 'colon' },\n  ',': { type: 'comma' },\n  '(': { type: 'openParen' },\n  ')': { type: 'closeParen' },\n  '?': { type: 'question' },\n  '+': {\n    type: 'binaryOp',\n    precedence: 30,\n    eval: (left, right) => left + right\n  },\n  '-': {\n    type: 'binaryOp',\n    precedence: 30,\n    eval: (left, right) => left - right\n  },\n  '*': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => left * right\n  },\n  '/': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => left / right\n  },\n  '//': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => Math.floor(left / right)\n  },\n  '%': {\n    type: 'binaryOp',\n    precedence: 50,\n    eval: (left, right) => left % right\n  },\n  '^': {\n    type: 'binaryOp',\n    precedence: 50,\n    eval: (left, right) => Math.pow(left, right)\n  },\n  '==': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left == right\n  },\n  '!=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left != right\n  },\n  '>': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left > right\n  },\n  '>=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left >= right\n  },\n  '<': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left < right\n  },\n  '<=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left <= right\n  },\n  '&&': {\n    type: 'binaryOp',\n    precedence: 10,\n    eval: (left, right) => left && right\n  },\n  '||': {\n    type: 'binaryOp',\n    precedence: 10,\n    eval: (left, right) => left || right\n  },\n  in: {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => {\n      if (typeof right === 'string') {\n        return right.indexOf(left) !== -1\n      }\n      if (Array.isArray(right)) {\n        return right.some(elem => elem === left)\n      }\n      return false\n    }\n  },\n  '!': {\n    type: 'unaryOp',\n    precedence: Infinity,\n    eval: right => !right\n  }\n}\n"],"sourceRoot":""}